<html>
	<head>
		<title>zenith</title>
		<style>

            body { width: 100%; height: 100%; margin: 0; padding: 0; height: 100%;
				overflow:hidden;}
            
            a {
                color: #fff;
                background: rgba(255, 255, 255, 0.2);
                text-decoration: none;
                padding: 15px;
                border-radius: 7px;
                text-align: center;
                display: none;
            }
            
            #splashscreen {
                position:absolute;
                top:0;
                left:0;
                bottom:0;
                width:100%;
                color: #fff;
                background-color:black;
            }
            
            #starName { 
                position: absolute;
                top: 0px; 
                left: 0px;
				padding: 5px;
                background-color: #faffd5;
                display: none;
            }
            
            #lineName { 
                position: absolute;
                top: 0px; 
                left: 0px;
				padding: 5px;
                background-color: #faffd5;
                display: none;
            }

        </style>
	</head>
    
	<body>
<!--
        <div id="splashscreen">
       
                <h1>Zenith</h1>
                An interactive constellations view
                <br/><br/><a href="#" class="explore" onclick="moveCam();">Explore</a>
            
        </div>
-->
        <a href="#" class="Aries">Aries</a>
        <a href="#" class="Capricorn">Capricorn</a>
        
        <div id="starName">No star hovered</div>
        <div id="lineName">No constellation hovered</div>
        
		<script src="js/three.min.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script> 
        <script src="js/jquerymodal.js"></script>
        <script src="js/jquery-csv.min.js"></script>
        <script src="js/tween.min.js"></script>
		<script>
            var scene, camera, renderer, axes;
            
            //raycasting
            var projector, raycaster;
            var mouse = new THREE.Vector2(), INTERSECTED, currentIntersected;
            var sceneLines, intLines;
            
            var starData, lineData, stars, outerGlow;
            var windowx = window.innerWidth;
            var windowy = window.innerHeight;
            var positionScale = 0.9;
 
            
            $( document ).ready(function() {
                $.get( "data/constellation_data.csv", function( data ) {
                    starData = $.csv.toArrays(data);
                    console.log("constellation data ready!");
                    
                    $.get( "data/line_order.csv", function( data ) {
                    lineData = $.csv.toArrays(data);
                    console.log("line data ready!");
                        
                        init();
                    });
                    
                    $('.Aries').paulund_modal_box({
                        title:'Aries - The Ram <br/> March 21 - April 19',
                        description:"In Greek mythology, Aries represents the ram whose fleece was sought by Jason and the Argonauts. When King Athamus of Boetia took a second wife, Ino, she was resentful of his existing children, especially his son, Phrixus, and she wanted him sacrificed. Zeus responded to the pleadings of Phrixus' mother, Nephele, by sending a golden ram to save Phrixus and his sister Helle. Helle did not survive but Phrixus did and sacrificed the ram to Zeus and gave its golden fleece to King Aettes. The fleece was eventually stolen by Jason."
                        ,
                        height: '500',
                        width: '800'
                    });
                    
                    $('.Capricorn').paulund_modal_box({
                        title:'Capricorn - The Sea Goat <br/> December 22 - January 19',
                        description:"The constellation has its roots in the cultures of Sumeria — which identified it with a mythical figure that was half goat and half fish — and Babylonia, which portrayed it as a goat-human hybrid. <br/>The Greeks associate the constellation with Pan, the god of nature. Part of Pan’s lore was that he helped Zeus fight the Titans to earn his spot in the heavens. He escaped the monster Typhon by jumping into Nile, but only half of his body was submerged, so he was a fish in the part of his body that remained underwater. Other spins on the tale have the constellation associated with Amalthaea, the mythical goat that acted as a foster mother to Zeus as an infant."
                        ,
                        height: '500',
                        width: '800'
                    });
                    
                });
                                
             // splashscreen
                $('.explore').click(function () {
                    $(this).parent('#splashscreen').fadeOut(500);
                });       
                    //starData[1][7]

            });

            function init(){
                if ( !Detector.webgl ) Detector.addGetWebGLMessage();
                scene = new THREE.Scene();
                

                //we need to see the world
                camera = new THREE.PerspectiveCamera(50, windowx/windowy, 0.1, 1000);
                camera.position.set(0,10,100);

                //we need to update the display
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(windowx, windowy);
         
                document.body.appendChild(renderer.domElement);
                
                //let there be light
                
                var light	= new THREE.AmbientLight( 0x888888 );
	           scene.add( light );
                
                var light = new THREE.SpotLight( 0xCCCCCC, 1, 0, Math.PI, 1);
                light.position.set(20,50,50);
                scene.add(light);
                
                // earth woo
                geometry = new THREE.SphereGeometry(0.5, 32, 32);
                material  = new THREE.MeshPhongMaterial();
                var earth = new THREE.Mesh(geometry, material);  
                earth.scale.set(0.5,0.5,0.5);
                earth.position.set(0, 0, 0);
                
                 material.map    = THREE.ImageUtils.loadTexture('imgs/earthmap.jpg'); // map color texture to sphere
                
                //map bump
                material.bumpMap    = THREE.ImageUtils.loadTexture('imgs/earthbump1k.jpg'); 
                material.bumpScale = 0.08;
                
                //specular light, only shiny things are water
                material.specularMap    = THREE.ImageUtils.loadTexture('imgs/earthspec1k.jpg');
                material.specular  = new THREE.Color('grey');
                
                scene.add(earth);
                                
                var geometry   = new THREE.SphereGeometry(0.51, 32, 32);
                var material  = new THREE.MeshPhongMaterial({
                   // map     : new THREE.Texture(canvasCloud), //load texture from?
                  map     : THREE.ImageUtils.loadTexture('imgs/earthcloudmap.png'),
                  side        : THREE.DoubleSide,
                  opacity     : 0.8,
                  transparent : true,
                  depthWrite  : false,
                });
                var cloudMesh = new THREE.Mesh(geometry, material);
                earth.add(cloudMesh);
                
                
                //galaxy
                var geometry  = new THREE.SphereGeometry(90, 32, 32);
                var material  = new THREE.MeshBasicMaterial();
                var galaxy = new THREE.Mesh(geometry, material);
                
                material.map   = THREE.ImageUtils.loadTexture('imgs/galaxy.png');
                material.side  = THREE.BackSide; //inside of sphere
                // create the mesh based on geometry and material
                var mesh  = new THREE.Mesh(geometry, material);
                scene.add(galaxy);
                
                
                // map negative absolute magnitude ranges
                function map_range(value, low1, high1, low2, high2) {
                    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
                }

                //draw spheres for each star in the constellation based off csv data
                geometry = new THREE.SphereGeometry(1, 30, 30);
               
                stars = new THREE.Object3D();
                scene.add( stars );
                
                outerGlow = new THREE.Object3D();
                scene.add( outerGlow );
                
                var spriteMaterial = new THREE.SpriteMaterial( 
                { 
                    map: new THREE.ImageUtils.loadTexture( 'imgs/glow.png' ), 
                    color: 0xCCFFFF, transparent: false, blending: THREE.AdditiveBlending
                });
                        
                for (var i = 1; i < starData.length; i++) {
                    var sprite = new THREE.Sprite( spriteMaterial );
                    
                    star = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({color:0x99FFCC, transparent: true, opacity : 0.5})); 
                    // map magnitude for brightness, parseFloat(starData[i][2])
                    
                    star.position.x = parseFloat(starData[i][4] *positionScale); 
                    star.position.y = parseFloat(starData[i][5] *positionScale);
                    star.position.z = parseFloat(starData[i][6] *positionScale);
                    
                    sprite.position.set(star.position.x, star.position.y, star.position.z);
//                    star.name=starData[i][7] + " " + starData[i][8];
                    
                    sprite.name = starData[i][8];
                    star.name=starData[i][7];

                    // for magnitude, the more negative a number, the brighter MAKE NEGATIVE Inverse problem
                    
                    // from asbolute magnitude, don't forget to change range values. NEED INVERT MATRIX
                    var absoMag = map_range(parseFloat(starData[i][3]), -3.297647909, 2.304163211 , 0, 1.5) * 0.5;
                    var glowMag = absoMag*4;

                    star.scale.set(absoMag,absoMag,absoMag);
                    sprite.scale.set(glowMag, glowMag, glowMag);

                    stars.add(star);
                    outerGlow.add(sprite);
                }
                
                // draw lines for constellations
                sceneLines = new THREE.Object3D();
                scene.add(sceneLines);
                
                intLines = new THREE.Object3D();
                
                function drawLines(constellation, constName) {                   
                    var linegeometry = new THREE.Geometry();
                    material = new THREE.LineBasicMaterial({color: 0xffffff, transparent: true, opacity : 0.2});

                    for (var h = 1; h < lineData[constellation].length; h++) {
                        linegeometry.hip = lineData[constellation][h];

                        for (var i = 1; i < starData.length; i++) {
                        star.hip = starData[i][0]; //constellation name

                            if (star.hip == linegeometry.hip) {
                                star.position.x = parseFloat(starData[i][4] *positionScale); 
                                star.position.y = parseFloat(starData[i][5] *positionScale);
                                star.position.z = parseFloat(starData[i][6] *positionScale);

                                linegeometry.vertices.push( star.position.clone() );
                            }
                        }  		
                }

                var lines = new THREE.Line( linegeometry, material );
                var lines2 = new THREE.Line( linegeometry, material );
                lines.name = constName;
                lines2.name = constName;
                sceneLines.add( lines );
                intLines.add( lines2 );

                }
                
                drawLines(0, "Aries"); // aries
                drawLines(1, "Capricorn"); //capricorn

        
                // raycasting

                projector = new THREE.Projector();
				raycaster = new THREE.Raycaster();
                
                // User interaction
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                
                function onDocumentMouseMove( event ) {
                    
                    event.preventDefault();
                    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		
                    // label
                    var starlabel = document.getElementById("starName");

                    var vector = new THREE.Vector3( mouse.x, mouse.y, 1 ).unproject( camera );

                    raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
                    var intersects = raycaster.intersectObjects( stars.children );
                
                     // mouse position for label
                    var x = event.clientX;  
                    var y = event.clientY; 
                    
                    // check if intersecting with star
                    if ( intersects.length > 0 ) {
                        if ( INTERSECTED != intersects[ 0 ].object ) {

                            INTERSECTED = intersects[ 0 ].object;
                            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                            // yes intersecting do this
                            INTERSECTED.material.opacity= 0.9;

                            starlabel.innerHTML = INTERSECTED.name;
                            starlabel.style.top = y+20 + 'px';
                            starlabel.style.left = x+20 + 'px';
                            starlabel.style.display = "initial";
                        }

                    } else {
                        if ( INTERSECTED ) {INTERSECTED.material.opacity= 0.5;
                                           starlabel.style.display = "none";}
                        INTERSECTED = null;
                    }       
                    
                    //line variables
                    var linelabel = document.getElementById("lineName");
                    var lineintersects = raycaster.intersectObjects( sceneLines.children, true);
                    
                    //check if intersecting with line
                    if ( lineintersects.length > 0 ) {

                        if ( lineintersects[ 0 ].object != currentIntersected ) {

                            currentIntersected = lineintersects[ 0 ].object;
                            currentIntersected.material.opacity= 0.6;
                            
                            linelabel.innerHTML = currentIntersected.name;
                            linelabel.style.top = y-50 + 'px';
                            linelabel.style.left = x-50 + 'px';
                            linelabel.style.display = "initial";
                            
                        }

                    } else {

                        if ( currentIntersected ) {currentIntersected.material.opacity= 0.2;
                                                   linelabel.style.display = "none";}
                       currentIntersected = null;

                    } 

                }
                            
                // camera controls
                controls = new THREE.OrbitControls(camera);
                controls.zoomSpeed = 0.1;
                render();
                
                 // Axes
                axes = buildAxes();
                scene.add( axes );
            }
            
            // modal
            document.onmousedown = function(e) {
                
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                
                var vector = new THREE.Vector3( mouse.x, mouse.y, 1 ).unproject( camera );
                raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
                var intersects = raycaster.intersectObjects( outerGlow.children );
                
                // check if intersecting with lines
                var lineintersects = raycaster.intersectObjects( intLines.children, true);
                    
                    //check if intersecting with line
                    if ( lineintersects.length > 0 ) {

                        if ( lineintersects[ 0 ].object != currentIntersected ) {

                            currentIntersected = lineintersects[ 0 ].object;

                            // trigger modal
                            $('.'+currentIntersected.name).click();
                        }

                    } else {
                       currentIntersected = null;

                    } 
            }
            
            // animations
            function moveCam(){

                    var pos1 = new TWEEN.Tween(camera.position).to({z:-200, x: 200}, 8000).easing(TWEEN.Easing.Quadratic.InOut);
                    var rot1 = new TWEEN.Tween(camera.rotation).to({y:-3}, 8000).easing(TWEEN.Easing.Quadratic.InOut); //rotation in radians, 3.14 = full 180
                    
                pos1.chain(rot1); //connect 
                pos1.start();
            }

            //render scene 60 fps
			function render() {
				requestAnimationFrame(render);

                camera.lookAt (scene.position);
                
                //for labels
                camera.updateMatrixWorld();
                
				renderer.render(scene, camera);
                controls.update();
                
                TWEEN.update();
                
			}
            
            // http://soledadpenades.com/articles/three-js-tutorials/drawing-the-coordinate-axes/
                function buildAxes() {
                    var axes = new THREE.Object3D();

                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 100, 0, 0 ), 0xFF0000, false ) ); // +X
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -100, 0, 0 ), 0x800000, true) ); // -X
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 100, 0 ), 0x00FF00, false ) ); // +Y
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -100, 0 ), 0x008000, true ) ); // -Y
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 100 ), 0x0000FF, false ) ); // +Z
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -100 ), 0x000080, true ) ); // -Z

                    return axes;

                }

                function buildAxis( src, dst, colorHex, dashed ) {
                    var geom = new THREE.Geometry(),
                        mat; 

                    if(dashed) {
                        mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: 5, gapSize: 5 });
                    } else {
                        mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
                    }

                    geom.vertices.push( src.clone() );
                    geom.vertices.push( dst.clone() );

                    var axis = new THREE.Line( geom, mat );

                    return axis;

                }

		</script>
	</body>
</html>